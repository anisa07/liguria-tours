---
import type { HTMLAttributes } from "astro/types";
import { cn } from "@/lib/utils";

interface Props extends HTMLAttributes<"div"> {
  value: number;
  max?: number;
  size?: "xs" | "sm" | "md" | "lg" | "xl";
  variant?: "default" | "gradient" | "striped" | "animated";
  color?: "primary" | "secondary" | "success" | "warning" | "error" | "info";
  showValue?: boolean;
  showPercentage?: boolean;
  label?: string;
  indeterminate?: boolean;
  animated?: boolean;
  rounded?: boolean;
}

const {
  value,
  max = 100,
  size = "md",
  variant = "default",
  color = "primary",
  showValue = false,
  showPercentage = false,
  label,
  indeterminate = false,
  animated = false,
  rounded = true,
  class: className = "",
  ...rest
} = Astro.props;

// Calculate percentage
const percentage = indeterminate
  ? 0
  : Math.min(Math.max((value / max) * 100, 0), 100);

// Size classes
const sizeClasses = {
  xs: "h-1",
  sm: "h-2",
  md: "h-3",
  lg: "h-4",
  xl: "h-6",
};

// Color classes using CSS variables
const getColorClasses = (color: string) => {
  switch (color) {
    case "secondary":
      return "bg-muted";
    case "success":
      return "bg-success";
    case "warning":
      return "bg-warning";
    case "error":
      return "bg-destructive";
    case "info":
      return "bg-info";
    default:
      return "bg-primary";
  }
};

// Gradient classes using CSS variables
const getGradientClasses = (color: string) => {
  switch (color) {
    case "secondary":
      return "bg-gradient-to-r from-muted/80 to-muted";
    case "success":
      return "bg-gradient-to-r from-success/80 to-success";
    case "warning":
      return "bg-gradient-to-r from-warning/80 to-warning";
    case "error":
      return "bg-gradient-to-r from-destructive/80 to-destructive";
    case "info":
      return "bg-gradient-to-r from-info/80 to-info";
    default:
      return "bg-gradient-to-r from-primary/80 to-primary";
  }
};

// Variant specific classes
const getVariantClasses = (variant: string, color: string) => {
  switch (variant) {
    case "gradient":
      return getGradientClasses(color);
    case "striped":
      return `${getColorClasses(color)} bg-stripes`;
    case "animated":
      return `${getColorClasses(color)} bg-stripes animate-stripes`;
    default:
      return getColorClasses(color);
  }
};

const progressId = `progress-${Math.random().toString(36).substr(2, 9)}`;
---

<div class={cn("w-full", className)} {...rest}>
  <!-- Label and Value -->
  {
    (label || showValue || showPercentage) && (
      <div class="flex justify-between items-center mb-2">
        {label && (
          <span
            class="text-sm font-medium text-muted-foreground"
            id={`${progressId}-label`}
          >
            {label}
          </span>
        )}

        {(showValue || showPercentage) && !indeterminate && (
          <span class="text-sm font-medium text-muted-foreground">
            {showPercentage && `${Math.round(percentage)}%`}
            {showValue && showPercentage && " "}
            {showValue && `${value}/${max}`}
          </span>
        )}
      </div>
    )
  }

  <!-- Progress Bar Container -->
  <div
    class={cn(
      "w-full bg-muted overflow-hidden",
      rounded ? "rounded-full" : "rounded-none",
      sizeClasses[size]
    )}
    role="progressbar"
    aria-valuenow={indeterminate ? undefined : value}
    aria-valuemin="0"
    aria-valuemax={max}
    aria-labelledby={label ? `${progressId}-label` : undefined}
    aria-label={!label ? "Progress" : undefined}
  >
    <!-- Progress Fill -->
    <div
      class={cn(
        "h-full transition-all duration-300 ease-out",
        getVariantClasses(variant, color),
        indeterminate && "animate-indeterminate",
        animated && !indeterminate && "animate-pulse"
      )}
      style={indeterminate ? "width: 30%" : `width: ${percentage}%`}
    >
      <!-- Inner glow effect for enhanced variants -->
      {
        (variant === "gradient" || variant === "animated") && (
          <div class="h-full w-full bg-background/20 animate-shimmer" />
        )
      }
    </div>
  </div>

  <!-- Accessibility: Screen reader percentage -->
  <div class="sr-only" aria-live="polite" aria-atomic="true">
    {
      indeterminate
        ? "Loading in progress"
        : `${Math.round(percentage)}% complete`
    }
  </div>
</div>

<style>
  /* Striped background pattern */
  .bg-stripes {
    background-image: linear-gradient(
      45deg,
      hsl(var(--background) / 0.15) 25%,
      transparent 25%,
      transparent 50%,
      hsl(var(--background) / 0.15) 50%,
      hsl(var(--background) / 0.15) 75%,
      transparent 75%,
      transparent
    );
    background-size: 1rem 1rem;
  }

  /* ProgressBar animations - using centralized animations.css */
  /* Component-specific styling preserved, animations centralized */

  /* Shimmer effect background for enhanced variants */
  .animate-shimmer {
    background: linear-gradient(
      90deg,
      transparent,
      hsl(var(--background) / 0.4),
      transparent
    );
    background-size: 200% 100%;
  }

  /* Indeterminate progress transform origin */
  .animate-indeterminate {
    transform-origin: left center;
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .bg-neutral-200 {
      background-color: hsl(var(--muted));
    }

    .text-neutral-700 {
      color: hsl(var(--muted-foreground));
    }
  }

  /* High contrast mode */
  @media (prefers-contrast: high) {
    [role="progressbar"] {
      border: 2px solid;
    }

    .bg-neutral-200 {
      background-color: hsl(var(--background));
      border: 1px solid hsl(var(--foreground));
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .animate-stripes,
    .animate-indeterminate,
    .animate-shimmer,
    .animate-pulse {
      animation: none;
    }

    .transition-all {
      transition: none;
    }
  }

  /* Focus styles */
  [role="progressbar"]:focus {
    outline: 2px solid hsl(var(--primary));
    outline-offset: 2px;
  }
</style>

<script>
  // Enhanced progress bar functionality
  function setupProgressBars() {
    const progressBars = document.querySelectorAll('[role="progressbar"]');

    progressBars.forEach((bar: Element) => {
      const barEl = bar as HTMLElement;
      const fillEl = barEl.querySelector("div") as HTMLElement;

      // Animate progress changes
      let animationFrame: number;

      function animateProgress(targetWidth: number) {
        const currentWidth = parseFloat(fillEl.style.width || "0");
        const diff = targetWidth - currentWidth;
        const step = diff * 0.1;

        if (Math.abs(diff) > 0.1) {
          const newWidth = currentWidth + step;
          fillEl.style.width = `${newWidth}%`;
          animationFrame = requestAnimationFrame(() =>
            animateProgress(targetWidth)
          );
        } else {
          fillEl.style.width = `${targetWidth}%`;
        }
      }

      // Observe value changes
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (
            mutation.type === "attributes" &&
            mutation.attributeName === "aria-valuenow"
          ) {
            const newValue = parseFloat(
              barEl.getAttribute("aria-valuenow") || "0"
            );
            const max = parseFloat(
              barEl.getAttribute("aria-valuemax") || "100"
            );
            const percentage = (newValue / max) * 100;

            if (animationFrame) {
              cancelAnimationFrame(animationFrame);
            }
            animateProgress(percentage);
          }
        });
      });

      observer.observe(barEl, { attributes: true });

      // Cleanup on element removal
      const parentObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            if (node === barEl) {
              observer.disconnect();
              parentObserver.disconnect();
              if (animationFrame) {
                cancelAnimationFrame(animationFrame);
              }
            }
          });
        });
      });

      if (barEl.parentNode) {
        parentObserver.observe(barEl.parentNode, { childList: true });
      }
    });
  }

  // Setup progress bar animations (for static progress bars)
  setupProgressBars();
</script>
